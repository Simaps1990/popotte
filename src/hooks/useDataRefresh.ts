// Ce fichier a Ã©tÃ© supprimÃ© car la logique de rafraÃ®chissement manuel est obsolÃ¨te.
// Toute la synchronisation des donnÃ©es doit dÃ©sormais passer par les abonnements temps rÃ©el Supabase et la fusion locale/serveur.
// Si vous voyez cette importation, supprimez le hook useDataRefresh dans les composants concernÃ©s.

/**
 * Hook personnalisÃ© pour dÃ©tecter et traiter les demandes de rechargement des donnÃ©es
 * Ã€ utiliser dans les composants de page pour recharger les donnÃ©es lorsque nÃ©cessaire
 * @param refreshCallback Fonction Ã  appeler pour recharger les donnÃ©es
 */
export const useDataRefresh = (refreshCallback: () => void) => {
  const location = useLocation();
  const refreshedRef = useRef(false);
  
  useEffect(() => {
    // VÃ©rifier si un rechargement des donnÃ©es est demandÃ©
    const shouldRefresh = sessionStorage.getItem('forceDataRefresh') === 'true';
    const lastPath = sessionStorage.getItem('lastPath');
    
    // Si un rechargement est demandÃ© et que nous sommes sur la bonne page
    if (shouldRefresh && lastPath === location.pathname && !refreshedRef.current) {
      console.log(`ðŸ”„ Rechargement des donnÃ©es dÃ©tectÃ© pour ${location.pathname}`);
      
      // Marquer comme traitÃ© pour Ã©viter les rechargements multiples
      refreshedRef.current = true;
      
      // Nettoyer le flag de rechargement
      sessionStorage.removeItem('forceDataRefresh');
      
      // Appeler la fonction de rechargement
      refreshCallback();
    }
    
    // RÃ©initialiser le flag lorsque l'utilisateur quitte la page
    return () => {
      refreshedRef.current = false;
    };
  }, [location.pathname, refreshCallback]);
};
